/*
 * Copyright Â© 2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/** \file depthstencil-render-miplevels.cpp
 *
 * Test that data rendered to depth and stencil textures
 * always lands at the correct miplevel.
 *
 * This test operates by creating a set of texture buffers, attaching
 * them to a framebuffer one miplevel at a time, and rendering
 * different data into each miplevel.  Then it verifies, using
 * glReadPixels, that the correct data appears at each miplevel.
 *
 * This is useful in diagnosing bugs such as:
 *
 * - Incorrect miplevels being attached to the framebuffer
 *
 * - Miplevels being laid out incorrectly in memory (e.g. in an
 *   overlapping fashion)
 *
 * Usage: depthstencil-render-miplevels GL_TEXTURE_2D <texture_size> <buffer_combination>
 *
 *   Available buffer combinations:
 *   s=z24_s8
 *   d=z24_s8
 *   d=z24
 *   d=z32f_s8
 *   d=z32f
 *   d=z16
 *   d=z24_s8_s=z24_s8
 *   d=z24_s=z24_s8
 *   s=z24_s8_d=z24_s8
 *   s=z24_s8_d=z24
 *   d=s=z24_s8
 *   s=d=z24_s8
 *   ds=z24_s8
 *   d=z32f_s8_s=z24_s8
 *   d=z32f_s=z24_s8
 *   s=z24_s8_d=z32f_s8
 *   s=z24_s8_d=z32f
 *   d=s=z32f_s8
 *   s=d=z32f_s8
 *   ds=z32f_s8
 *
 * Buffer combination is interpreted as follows:
 *   s=GL_STENCIL_ATTACHMENT
 *   d=GL_DEPTH_ATTACHMENT
 *   ds=GL_DEPTH_STENCIL_ATTACHMENT
 *   z16=GL_DEPTH_COMPONENT16
 *   z24=GL_DEPTH_COMPONENT24
 *   z32f=GL_DEPTH_COMPONENT32f
 *   z24_s8=GL_DEPTH24_STENCIL8
 *   z32f_s8=GL_DEPTH32F_STENCIL8
 *
 * So, for example:
 *
 * - d=z24_s=z24_s8 means that GL_DEPTH_ATTACHMENT is bound to a
 *   buffer of type GL_DEPTH_COMPONENT24, and then
 *   GL_STENCIL_ATTACHMENT is bound to a buffer of type
 *   GL_DEPTH24_STENCIL8.
 *
 * - s=d=z32f_s8 means that GL_STENCIL_ATTACHMENT is bound to a buffer
 *   of type GL_DEPTH32F_STENCIL8 and then GL_DEPTH_ATTACHMENT is
 *   bound to the same buffer.
 */

#include "piglit-util-gl-common.h"

PIGLIT_GL_TEST_CONFIG_BEGIN

	config.supports_gl_compat_version = 10;
	config.window_visual = PIGLIT_GL_VISUAL_RGB | PIGLIT_GL_VISUAL_DOUBLE;

PIGLIT_GL_TEST_CONFIG_END

namespace {

struct texture_layer {
	/**
	 * \name Pixel data
	 *
	 * For each layer, we set all pixels to the same value, a value that
	 * is unique to that layer. Later, we may retrieve the layer's pixel data
	 * with glReadPixels(), storing the result in the readpixels_data
	 * arrays below, and then verify that the pixels returned by glReadPixels()
	 * have the expected value.
	 *
	 * Not all sub-structs below may be initialized. If the texture format
	 * has a depth component, then the depth struct is initialized. Likewise
	 * for a stencil component. If the texture format has a depth and
	 * stencil component, then both are initialized.
	 *
	 * \{
	 */
	struct {
		float expected_value;

		GLenum readpixels_format;
		GLenum readpixels_type;
		float *readpixels_data;
	} depth;

	struct {
		uint8_t expected_value;

		GLenum readpixels_format;
		GLenum readpixels_type;
		uint8_t *readpixels_data;
	} stencil;

	/** \} */
};

struct texture_level {
	int width;
	int height;

	/**
	 * \brief Number of layers in this texture level.
	 *
	 * For GL_TEXTURE_2D, there is exacty one layer.
	 * For GL_TEXTURE_2D_ARRAY, this is the length of the array.
	 */
	int num_layers;

	struct texture_layer *layers;
};

/**
 * This structure captures all information needed by this test for each
 * texture: the GL name; GL target; ancillary format data; the dimensions
 * of each texture level; the pixel value written to each texture layer;
 * and the data read from each layer with glReadPixels().
 */
struct texture {
	/**
	 * Name generated by glGenTexture().
	 */
	GLuint name;

	/**
	 * \name Parameters given to glTexImage*().
	 * \{
	 */
	GLenum target;
	GLenum internal_format;
	GLenum format;
	GLenum type;
	/** \} */

	int width0;
	int height0;

	int num_levels;
	struct texture_level *levels;
};

#define texture_foreach_layer(tex, level, layer) \
	\
	for (level = 0, layer = 0; \
	     level < tex->num_levels; \
	     (++layer == tex->levels[level].num_layers) \
		&& ((layer = 0), ++level))

/**
 * The final test result. It's global because piglit_init() must pass it
 * to piglit_display().
 */
enum piglit_result result = PIGLIT_FAIL;

const char *prog_name;

const struct texture *color_tex;
const struct texture *depth_tex;
const struct texture *stencil_tex;

bool attach_depth = false;
bool attach_stencil = false;
bool shared_attachment = false;
bool attach_together = false;
bool attach_stencil_first = false;

/**
 * When displaying texture in non-auto mode, this is the size
 * of padding, in pixels, between miplevels.
 */
static const int pad = 8;

static int
minify(int n, int levels)
{
	return MAX2(n >> levels, 1);
}

/**
 * Skip the test if the texture internal format is unsupported.
 */
static void
check_internal_format(GLenum internal_format)
{
	switch (internal_format) {
	case GL_DEPTH_COMPONENT32F:
	case GL_DEPTH32F_STENCIL8:
		if (!piglit_is_extension_supported("GL_ARB_depth_buffer_float")) {
			printf("internal_format=%s is unsupported\n",
			       piglit_get_gl_enum_name(internal_format));
			piglit_report_result(PIGLIT_SKIP);
		}
		break;
	case GL_RGBA:
	case GL_DEPTH_COMPONENT16:
	case GL_DEPTH_COMPONENT24:
	case GL_DEPTH24_STENCIL8:
	default:
		break;
	}
}

static void
texture_init_layer(struct texture *tex, int level, int layer)
{
	struct texture_layer *l = &tex->levels[level].layers[layer];
	const int width = tex->levels[level].width;
	const int height = tex->levels[level].height;

	/* Calculate the value with which we later populate the layer.
	 * We use a unique value for each layer. This allows us to detect
	 * if one layer's data leaks into another layer.
	 */
	const float depth_value = ((float) level + 1) / tex->num_levels;

	if (tex->format == GL_DEPTH_COMPONENT ||
	    tex->format == GL_DEPTH_STENCIL) {
		l->depth.expected_value = depth_value;
		l->depth.readpixels_format = GL_DEPTH_COMPONENT;
		l->depth.readpixels_type = GL_FLOAT;
		l->depth.readpixels_data =
			(float*) malloc(sizeof(float) * width * height);
	}

	if (tex->format == GL_DEPTH_STENCIL) {
		l->stencil.expected_value = (uint8_t) round(depth_value * 255.0);
		l->stencil.readpixels_format = GL_STENCIL_INDEX;
		l->stencil.readpixels_type = GL_UNSIGNED_BYTE;
		l->stencil.readpixels_data =
			(uint8_t*) malloc(sizeof(uint8_t) * width * height);
	}
}

static void
texture_init_level(struct texture *tex, int level)
{
	struct texture_level *l = &tex->levels[level];

	l->width = minify(tex->width0, level);
	l->height = minify(tex->height0, level);
	l->num_layers = 1;
	l->layers = (typeof(l->layers)) malloc(l->num_layers *
					       sizeof(l->layers[0]));

	for (int layer = 0; layer < l->num_layers; ++layer) {
		texture_init_layer(tex, level, layer);
	}

	glTexImage2D(tex->target, level, tex->internal_format,
		     l->width, l->height, 0,
		     tex->format, tex->type, NULL);

	if (!piglit_check_gl_error(GL_NO_ERROR))
		piglit_report_result(PIGLIT_FAIL);
}

static const struct texture*
texture_new(GLenum target,
	    GLenum internal_format,
	    int width0,
	    int height0)
{
	struct texture *tex;

	/* This test supports only GL_TEXTURE_2D. */
	assert(target == GL_TEXTURE_2D);

	check_internal_format(internal_format);

	tex = (typeof(tex)) calloc(1, sizeof(*tex));
	tex->target = target;
	tex->internal_format = internal_format;


	if ((internal_format == GL_DEPTH_COMPONENT32F
	     || internal_format == GL_DEPTH32F_STENCIL8)
	    && !piglit_is_extension_supported("GL_ARB_depth_buffer_float")) {
		printf("internal_format=%s is not supported\n",
		       piglit_get_gl_enum_name(internal_format));
		piglit_report_result(PIGLIT_SKIP);
		return NULL;
	}

	switch (internal_format) {
	case GL_DEPTH_COMPONENT16:
	case GL_DEPTH_COMPONENT24:
	case GL_DEPTH_COMPONENT32:
	case GL_DEPTH_COMPONENT32F:
		tex->format = GL_DEPTH_COMPONENT;
		tex->type = GL_UNSIGNED_BYTE;
		break;
	case GL_DEPTH24_STENCIL8:
	case GL_DEPTH32F_STENCIL8:
		tex->format = GL_DEPTH_STENCIL;
		tex->type = GL_UNSIGNED_INT_24_8;
		break;
	case GL_RGBA:
		tex->format = GL_RGBA;
		tex->type = GL_UNSIGNED_BYTE;
		break;
	default:
		printf("%s:%d: Unexpected internal_format=0x%x\n",
		       __FILE__, __LINE__, internal_format);
		piglit_report_result(PIGLIT_FAIL);
		break;
	}

	tex->width0 = width0;
	tex->height0 = height0;
	tex->num_levels = 1 + MAX2(log2(width0), log2(height0));
	tex->levels = (typeof(tex->levels)) malloc(tex->num_levels *
						   sizeof(tex->levels[0]));

	glGenTextures(1, &tex->name);
	glBindTexture(tex->target, tex->name);

	for (int level = 0; level < tex->num_levels; ++level) {
		texture_init_level(tex, level);
	}

	return tex;
}

static void
texture_check_level(const struct texture *tex, int level)
{
	assert(level < tex->num_levels);
}

static void
texture_check_layer(const struct texture *tex, int level, int layer)
{
	texture_check_level(tex, level);
	assert(layer < tex->levels[level].num_layers);
}

static const struct texture_level*
texture_get_level(const struct texture *tex, int level)
{
	texture_check_level(tex, level);
	return &tex->levels[level];
}

static const struct texture_layer*
texture_get_layer(const struct texture *tex, int level, int layer)
{
	texture_check_layer(tex, level, layer);
	return &tex->levels[level].layers[layer];
}

static void
texture_attach_layer_to_framebuffer(const struct texture *tex,
				   int level, int layer,
				   GLenum attachment)
{
	/* Currently, the test supports only GL_TEXTURE_2D. */
	assert(tex->target == GL_TEXTURE_2D);
	texture_check_layer(tex, level, layer);

	glFramebufferTexture2D(GL_FRAMEBUFFER,
			       attachment, GL_TEXTURE_2D,
			       tex->name, level);

	if (!piglit_check_gl_error(GL_NO_ERROR))
		piglit_report_result(PIGLIT_FAIL);
}

/**
 * Attach the given layer of each texture to the framebuffer.
 */
static void
framebuffer_attach_textures(int level, int layer)
{
	texture_attach_layer_to_framebuffer(color_tex, level, layer,
					   GL_COLOR_ATTACHMENT0);

	if (attach_together) {
		texture_attach_layer_to_framebuffer(
			depth_tex, level, layer,
			GL_DEPTH_STENCIL_ATTACHMENT);
	} else if (attach_stencil_first) {
		texture_attach_layer_to_framebuffer(
			stencil_tex, level, layer,
			GL_STENCIL_ATTACHMENT);
		texture_attach_layer_to_framebuffer(
			depth_tex, level, layer,
			GL_DEPTH_ATTACHMENT);
	} else {
		if (attach_depth) {
		texture_attach_layer_to_framebuffer(
			depth_tex, level, layer,
			GL_DEPTH_ATTACHMENT);
		}
		if (attach_stencil) {
		texture_attach_layer_to_framebuffer(
			stencil_tex, level, layer,
			GL_STENCIL_ATTACHMENT);
		}
	}

	/* Some implementations don't support certain buffer
	 * combinations, and that's ok, provided that the
	 * implementation reports GL_FRAMEBUFFER_UNSUPPORTED.
	 * However, if the first call to this function resulted in a supported
	 * framebuffer combination, then all future calls should result in
	 * a supported framebuffer.
	 */
	static bool once = true;
	GLenum status = glCheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);

	if (once && status == GL_FRAMEBUFFER_UNSUPPORTED) {
		printf("This buffer combination is unsupported\n");
		piglit_report_result(PIGLIT_SKIP);
	} else if (status != GL_FRAMEBUFFER_COMPLETE) {
		printf("FBO incomplete for level=%d layer=%d\n",
		       level, layer);
		piglit_report_result(PIGLIT_FAIL);
	}

	once = false;
}

/**
 * Using glClear, set the contents of the depth and stencil buffers
 * (if present) to a value that is unique for the given layer.
 */
static void
framebuffer_populate_pixels(int level, int layer)
{
	GLbitfield clear_mask = 0;

	if (attach_depth) {
		glClearDepth(texture_get_layer(depth_tex, level, layer)->depth.expected_value);
		clear_mask |= GL_DEPTH_BUFFER_BIT;
	}
	if (attach_stencil) {
		glClearStencil(texture_get_layer(stencil_tex, level, layer)->stencil.expected_value);
		clear_mask |= GL_STENCIL_BUFFER_BIT;
	}

	glClear(clear_mask);
}

/**
 * Test that every pixel in the depth and stencil buffers (if present)
 * is equal to the expected value.
 *
 * If we're going to later render our results to the screen for
 * debugging, then save off a copy of the data we read now.
 */
static bool
framebuffer_probe(int level, int layer)
{
	bool pass = true;

	if (attach_depth) {
		const struct texture_level *depth_level =
			texture_get_level(depth_tex, level);

		const struct texture_layer *depth_layer =
			texture_get_layer(depth_tex, level, layer);

		printf("Probing level=%d layer=%d depth\n", level, layer);
		pass &= piglit_probe_rect_depth(
				0, 0,
				depth_level->width, depth_level->height,
				depth_layer->depth.expected_value);

		if (!piglit_automatic) {
			glReadPixels(0, 0,
				     depth_level->width,
				     depth_level->height,
				     depth_layer->depth.readpixels_format,
				     depth_layer->depth.readpixels_type,
				     depth_layer->depth.readpixels_data);
		}
	}

	if (attach_stencil) {
		const struct texture_level *stencil_level =
			texture_get_level(stencil_tex, level);

		const struct texture_layer *stencil_layer =
			texture_get_layer(stencil_tex, level, layer);

		printf("Probing level=%d layer=%d stencil\n", level, layer);
		pass &= piglit_probe_rect_stencil(
				0, 0,
				stencil_level->width, stencil_level->height,
				stencil_layer->stencil.expected_value);

		if (!piglit_automatic) {
			glReadPixels(0, 0,
				     stencil_level->width,
				     stencil_level->height,
				     stencil_layer->stencil.readpixels_format,
				     stencil_layer->stencil.readpixels_type,
				     stencil_layer->stencil.readpixels_data);
		}
	}

	return pass;
}

static void
print_usage_and_exit(void)
{
	printf("Usage: %s GL_TEXTURE_2D <texture_size> <buffer_combination>\n"
	       "    Available buffer combinations:\n"
	       "    s=z24_s8\n"
	       "    d=z24_s8\n"
	       "    d=z24\n"
	       "    d=z32f_s8\n"
	       "    d=z32f\n"
	       "    d=z16\n"
	       "    d=z24_s8_s=z24_s8\n"
	       "    d=z24_s=z24_s8\n"
	       "    s=z24_s8_d=z24_s8\n"
	       "    s=z24_s8_d=z24\n"
	       "    d=s=z24_s8\n"
	       "    s=d=z24_s8\n"
	       "    ds=z24_s8\n"
	       "    d=z32f_s8_s=z24_s8\n"
	       "    d=z32f_s=z24_s8\n"
	       "    s=z24_s8_d=z32f_s8\n"
	       "    s=z24_s8_d=z32f\n"
	       "    d=s=z32f_s8\n"
	       "    s=d=z32f_s8\n"
	       "    ds=z32f_s8\n",
	       prog_name);
	piglit_report_result(PIGLIT_FAIL);
}

static char*
pop_arg0(int *argc, char **argv)
{
	if (*argc == 0)
		print_usage_and_exit();

	char *arg0 = argv[0];
	for (int i = 0; i < *argc; ++i)
		argv[i] = argv[i + 1];

	*argc -= 1;
	return arg0;
}

static int
parse_int(char *arg)
{
	char *endptr = NULL;
	int i = strtol(arg, &endptr, 0);
	if (endptr != arg + strlen(arg))
		print_usage_and_exit();
	return i;
}

static void
parse_args(int argc, char *argv[],
	   GLenum *depth_format,
	   int *width0, int *height0)
{
	char *arg;

	prog_name = pop_arg0(&argc, argv);

	/* Parse texture target. */
	arg = pop_arg0(&argc, argv);
	if (strcmp(arg, "GL_TEXTURE_2D") != 0)
		print_usage_and_exit();

	/* Parse texture size. */
	*width0 = *height0 = parse_int(pop_arg0(&argc, argv));

	glPixelStorei(GL_PACK_ALIGNMENT, 1);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	/* Parse buffer combination. */
	arg = pop_arg0(&argc, argv);

	if (strcmp(arg, "s=z24_s8") == 0) {
		attach_stencil = true;
	} else if (strcmp(arg, "d=z24_s8") == 0) {
		attach_depth = true;
		*depth_format = GL_DEPTH24_STENCIL8;
	} else if (strcmp(arg, "d=z24") == 0) {
		attach_depth = true;
		*depth_format = GL_DEPTH_COMPONENT24;
	} else if (strcmp(arg, "d=z32f_s8") == 0) {
		attach_depth = true;
		*depth_format = GL_DEPTH32F_STENCIL8;
	} else if (strcmp(arg, "d=z32f") == 0) {
		attach_depth = true;
		*depth_format = GL_DEPTH_COMPONENT32F;
	} else if (strcmp(arg, "d=z16") == 0) {
		attach_depth = true;
		*depth_format = GL_DEPTH_COMPONENT16;
	} else if (strcmp(arg, "d=z24_s8_s=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		*depth_format = GL_DEPTH24_STENCIL8;
	} else if (strcmp(arg, "d=z24_s=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		*depth_format = GL_DEPTH_COMPONENT24;
	} else if (strcmp(arg, "s=z24_s8_d=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		attach_stencil_first = true;
		*depth_format = GL_DEPTH24_STENCIL8;
	} else if (strcmp(arg, "s=z24_s8_d=z24") == 0) {
		attach_depth = true;
		attach_stencil = true;
		attach_stencil_first = true;
		*depth_format = GL_DEPTH_COMPONENT24;
	} else if (strcmp(arg, "d=s=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		shared_attachment = true;
		*depth_format = GL_DEPTH24_STENCIL8;
	} else if (strcmp(arg, "s=d=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		shared_attachment = true;
		attach_stencil_first = true;
		*depth_format = GL_DEPTH24_STENCIL8;
	} else if (strcmp(arg, "ds=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		shared_attachment = true;
		attach_together = true;
		*depth_format = GL_DEPTH24_STENCIL8;
	} else if (strcmp(arg, "d=z32f_s8_s=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		*depth_format = GL_DEPTH32F_STENCIL8;
	} else if (strcmp(arg, "d=z32f_s=z24_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		*depth_format = GL_DEPTH_COMPONENT32F;
	} else if (strcmp(arg, "s=z24_s8_d=z32f_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		attach_stencil_first = true;
		*depth_format = GL_DEPTH32F_STENCIL8;
	} else if (strcmp(arg, "s=z24_s8_d=z32f") == 0) {
		attach_depth = true;
		attach_stencil = true;
		attach_stencil_first = true;
		*depth_format = GL_DEPTH_COMPONENT32F;
	} else if (strcmp(arg, "d=s=z32f_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		shared_attachment = true;
		*depth_format = GL_DEPTH32F_STENCIL8;
	} else if (strcmp(arg, "s=d=z32f_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		shared_attachment = true;
		attach_stencil_first = true;
		*depth_format = GL_DEPTH32F_STENCIL8;
	} else if (strcmp(arg, "ds=z32f_s8") == 0) {
		attach_depth = true;
		attach_stencil = true;
		shared_attachment = true;
		attach_together = true;
		*depth_format = GL_DEPTH32F_STENCIL8;
	} else {
		print_usage_and_exit();
	}

	if (argc != 0) {
		/* There exists trailing arguments. */
		print_usage_and_exit();
	}
}

extern "C" void
piglit_init(int argc, char **argv)
{
	bool pass = true;
	GLuint fbo;

	GLenum depth_format;
	int width0;
	int height0;

	parse_args(argc, argv, &depth_format, &width0, &height0);

	color_tex = texture_new(GL_TEXTURE_2D, GL_RGBA, width0, height0);

	if (attach_depth) {
		depth_tex = texture_new(GL_TEXTURE_2D, depth_format,
					width0, height0);
	}

	if (attach_stencil) {
		if (shared_attachment) {
			stencil_tex = depth_tex;
		} else {
			stencil_tex = texture_new(GL_TEXTURE_2D,
						  GL_DEPTH24_STENCIL8,
						  width0, height0);
		}
	}

	glGenFramebuffers(1, &fbo);
	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo);
	glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo);

	/* Iterate over the color texture's layers rather than the depth or
	 * stencil texture's, because in some test modes one of depth or
	 * stencil is missing. However, the color texture is always present and
	 * its miptree layout is the same as that of the depth and stencil
	 * textures.
	 */
	int level;
	int layer;
	texture_foreach_layer(color_tex, level, layer) {
		framebuffer_attach_textures(level, layer);
		framebuffer_populate_pixels(level, layer);
	}

	texture_foreach_layer(color_tex, level, layer) {
		framebuffer_attach_textures(level, layer);
		pass &= framebuffer_probe(level, layer);
	}

	result = pass ? PIGLIT_PASS : PIGLIT_FAIL;
	if (piglit_automatic)
		piglit_report_result(result);
}

static void
texture_walk_redscale_layout(
	const struct texture *tex,
	int start_x, int start_y,
	int *end_x, int *end_y,
	void (*callback)(const struct texture *tex,
			 int level, int layer, int x, int y,
			 void *callback_data),
	void *callback_data)
{
	int level, layer;
	int x, y;

	*end_x = x = start_x;
	*end_y = y = start_y;

	texture_foreach_layer(tex, level, layer) {
		const int width = texture_get_level(tex, level)->width;
		const int height = texture_get_level(tex, level)->height;

		assert(tex->target == GL_TEXTURE_2D);
		assert(layer == 0);

		if (callback) {
			callback(tex, level, layer, x, y, callback_data);
		}

		*end_x = MAX2(*end_x, x + width);
		*end_y = MAX2(*end_y, y + height);

		if (level == 0) {
			y += height + pad;
		} else if (level == 1) {
			x += width + pad;
		} else {
			y += height + pad;
		}
	}
}

static void
texture_get_redscale_size(const struct texture *tex,
			  int *width, int *height)
{
	texture_walk_redscale_layout(tex, 0, 0, width, height,
				     NULL /*callback*/,
				     NULL /*callback_data*/);
}

static void
texture_draw_redscale_slice(const struct texture *tex,
			    int level, int layer,
			    int x, int y,
			    void *callback_data)
{
	const struct texture_level *tex_level = texture_get_level(tex, level);
	const struct texture_layer *tex_layer = texture_get_layer(tex, level, layer);
	const int width = tex_level->width;
	const int height = tex_level->height;
	GLenum *base_format = (GLenum*) callback_data;

	GLenum type;
	void *data;

	assert(tex->target == GL_TEXTURE_2D);
	assert(layer == 0);

	switch (*base_format) {
	case GL_DEPTH_COMPONENT:
		type = tex_layer->depth.readpixels_type;
		data = tex_layer->depth.readpixels_data;
		break;
	case GL_STENCIL_INDEX:
		type = tex_layer->stencil.readpixels_type;
		data = tex_layer->stencil.readpixels_data;
		break;
	default:
		assert(0);
		type = 0;
		data = NULL;
		break;
	}

	glTexImage2D(GL_TEXTURE_2D, /*level*/ 0, GL_RGBA,
		     width, height,
		     /*border_color*/ 0, GL_RED,
		     type, data);

	if (!piglit_check_gl_error(GL_NO_ERROR))
		piglit_report_result(PIGLIT_FAIL);

	piglit_draw_rect_tex(x, y, width, height,
			     0, 0, 1, 1);

	if (!piglit_check_gl_error(GL_NO_ERROR))
		piglit_report_result(PIGLIT_FAIL);
}

static void
texture_draw_redscale(const struct texture *tex,
			    GLenum base_format,
			    int start_x, int start_y,
			    int *end_x, int *end_y)
{
	texture_walk_redscale_layout(
		tex, start_x, start_y, end_x, end_y,
		texture_draw_redscale_slice,
		&base_format);

}

static void
render_results_to_screen()
{
	GLuint red_tex;
	GLuint program;
	GLuint red_tex_uniform_location, proj_uniform_location;

	int x;
	int y;

	int redscale_width, redscale_height;
	int proj_width, proj_height;

	const char vs[] =
		"#version 120\n"
		"uniform mat4 proj;\n"
		"attribute vec4 piglit_vertex;\n"
		"attribute vec4 piglit_texcoord;\n"
		"varying vec2 tex_coord;\n"
		"\n"
		"void main () {\n"
		"    gl_Position = proj * piglit_vertex;\n"
		"    gl_Position.y *= -1;\n"
		"    tex_coord = piglit_texcoord.xy;\n"
		"}\n";

	const char fs[] =
		"#version 120\n"
		"uniform sampler2D red_tex; /* defaults to 0 */\n"
		"varying vec2 tex_coord;\n"
		"\n"
		"void main () {\n"
		"    gl_FragColor = texture2D(red_tex, tex_coord);\n"
		"}\n";

	printf("\n");
	printf("Depth is on the left, stencil is on the right.\n");
	printf("Colors should proceed from nearly-black to nearly-red.\n");

	glViewport(0, 0, piglit_width, piglit_height);

	glGenTextures(1, &red_tex);
	glBindTexture(GL_TEXTURE_2D, red_tex);
	glEnable(GL_TEXTURE_2D);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	program = piglit_build_simple_program_unlinked(vs, fs);
	glBindAttribLocation(program, PIGLIT_ATTRIB_POS, "piglit_vertex");
	glBindAttribLocation(program, PIGLIT_ATTRIB_TEX, "piglit_texcoord");
	glLinkProgram(program);
	glUseProgram(program);

	red_tex_uniform_location = glGetUniformLocation(program, "red_tex");
	assert(red_tex_uniform_location >= 0);
	glUniform1i(red_tex_uniform_location, 0);

	texture_get_redscale_size(color_tex, &redscale_width, &redscale_height);
	if (attach_depth && attach_stencil) {
		proj_width = pad + redscale_width + pad + redscale_width + pad;
	} else {
		proj_width = pad + redscale_width + pad;
	}
	proj_height = pad + redscale_height + pad;

	proj_uniform_location = glGetUniformLocation(program, "proj");
	assert(proj_uniform_location >= 0);
	piglit_gen_ortho_uniform(proj_uniform_location,
				 0, proj_width,
				 0, proj_height,
				 -1, 1);

	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
	glClearColor(0.5, 0.5, 0.5, 0.0);
	glClear(GL_COLOR_BUFFER_BIT);

	x = 0;
	y = 0;
	if (attach_depth) {
		texture_draw_redscale(depth_tex, GL_DEPTH_COMPONENT,
			 	      x + pad, y + pad, &x, &y);
	}

	y = 0;
	if (attach_stencil) {
		texture_draw_redscale(stencil_tex, GL_STENCIL_INDEX,
				      x + pad, y + pad, &x, &y);
	}

	piglit_present_results();

	glDeleteTextures(1, &red_tex);
}

extern "C" enum piglit_result
piglit_display()
{
	if (!piglit_automatic)
		render_results_to_screen();

	return result;
}

}; /* Anonymous namespace */

// vim:noet sw=8 ts=8:
