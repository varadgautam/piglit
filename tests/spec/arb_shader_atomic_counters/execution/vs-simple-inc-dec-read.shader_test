# Simple test of atomicCounterIncrement, atomicCounterDecrement and
# atomicCounter being used in the VS.

[require]
GLSL >= 1.40
GL_ARB_shader_atomic_counters
INT GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS >= 2

[vertex shader]
#version 140
#extension GL_ARB_shader_atomic_counters: require

layout(binding = 0) uniform atomic_uint a0;
layout(binding = 0) uniform atomic_uint a1;

in vec4 piglit_vertex;
out vec4 vcolor;

void main()
{
	bool passed = true;
	uint v0, v1;

	/* Test that incrementing, followed by a read of an atomic
	 * counter results in a larger value.
	 *
	 * Note: atomicCounterIncrement return the old value
	 */
	v0 = atomicCounterIncrement(a0);
	v1 = atomicCounter(a0);
	if (v1 <= v0)
		passed = false;

	/* Skip one decrement since it may be the 0 => 0xffffffff
	 * transition.
	 */
	atomicCounterDecrement(a1);

	/* Test that a read, followed by a decrement of an atomic
	 * counter results in a smaller value.
	 *
	 * Note: atomicCounterDecrement return the new value
	 */
	v0 = atomicCounter(a1);
	v1 = atomicCounterDecrement(a1);
	if (v1 >= v0)
		passed = false;

	if (passed)
		vcolor = vec4(0.0, 1.0, 0.0, 1.0);
	else
		vcolor = vec4(1.0, 0.0, 0.0, 1.0);

	gl_Position = piglit_vertex;
}

[fragment shader]
#version 140
in vec4 vcolor;
out vec4 fcolor;

void main()
{
	fcolor = vcolor;
}

[test]
atomic counters 2

draw rect -1 -1 2 2
probe all rgba 0.0 1.0 0.0 1.0
